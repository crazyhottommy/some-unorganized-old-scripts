
# This R script is to generate the TF or histone modification heatmap
# at certain genomic features (TSS, enhancers) from the ChIP-seq data
# the input matrix is got from Homer software. alternative to R, use cluster3 to cluster, and visualize by java Treeviewer
# generate the matrix by Homer: annotatePeaks.pl looping_HRE.txt hg19 -size 6000 -hist 10  -ghist -d HIF/ > outputfile.txt
# see several posts for heatmap:
# http://davetang.org/muse/2010/12/06/making-a-heatmap-with-r/
# http://www.r-bloggers.com/r-using-rcolorbrewer-to-colour-your-figures-in-r/
# 08/20/13 by Tommy Tang

# it is such a simple script but took me several days to get it work...I mean the desired
# color setting of the heatmap. Making a pretty figure takes time :)

library(gplots)

library(pheatmap) #somehow, I can not get the satisfactory color by heatmap.2 from gplots ( I do not know how...)
# pheatmap is fine for me, you can compare the heatmaps generated by heatmap.2 and pheatmap

setwd("/home/tommy/homer")

d1 <- read.table("Jund_looping_distal_HRE.txt", header=T)

head(d1)
d1$Gene
m1<- as.matrix( d1[,2:ncol(d1)])
rownames(m1)<- d1$Gene
m1<- log2(m1+1) # log2 transform the raw counts

d2<- read.table("random_promoters_max.txt", header=T)
m2<- as.matrix(d2[,2:ncol(d2)])
rownames(m2)<- d2$Gene
m2<- log2(m2+1)


d3<- read.table("random_promoters_jund.txt", header=T)
m3<- as.matrix(d3[,2:ncol(d3)])
rownames(m3)<- d3$Gene

d2<- read.table("Jund_non_looping_distal_HRE.txt", header=T)
m2<- as.matrix(d2[,2:ncol(d2)])
rownames(m2)<- d2$Gebe
m2<- log2(m2+1)


d3<- read.table("Jund_promoter_HRE.txt", header=T)
m3<- as.matrix(d3[,2:ncol(d3)])
rownames(m3)<- d3$Gebe

m3<- log2(m3+1)

#exam the data range
#> max(m1)
#[1] 12.44496
#> max(m2)
#[1] 9.438792
#> mean(m1)
#[1] 0.5901533
#> mean(m2)
#[1] 0.4002133
#> median(m1)
#[1] 0
#> median(m2)
#[1] 0
#> min(m1)
#[1] -2.857456e-13
#> min(m2)
#[1] -1.909242e-13
# hist(m1)
# hist(m2) histogram to look at distributions

# it is from the ChIP-seq count data, many of them are 0s. I transfromed the raw data
# by log2(m+1), so if the log2 value is 0, the raw number is also 0 (count)


# to compare different heatmaps, I have to map the value to the color using the
# break argument in pheatmap or heatmap.2, that's why I examed the data range
# http://stackoverflow.com/questions/17820143/how-to-change-heatmap-2-color-range-in-r
# https://stat.ethz.ch/pipermail/bioconductor/2011-November/041866.html
# http://seqanswers.com/forums/showthread.php?p=114275&posted=1#post114275


bk = unique(c(seq(-0.1,3, length=100),seq(3,9.45,length=100)))

# if just use bk =  c(seq(-0.1,1, length=100),seq(1,12.5,length=100)) without the unique function
# the pheatmap gave me error message:
# Error in cut.default(x, breaks = breaks, include.lowest = T) : 
# 'breaks' are not unique
# It is caused by concatenating several seq() results together, which share the same boundaries.
#

hmcols<- colorRampPalette(c("white","red"))(length(bk)-1)

hc.rows<- hclust(dist(m1), method = "ward") # use "ward" method to cluster the rows
# try ?dist ?hclust

rowDend<- as.dendrogram(hc.rows)

png("looping_HIF_heatmap_adjust3.png", width=300, height = 800) # width and height are in pixel 

pheatmap(m1, color=hmcols,  breaks= bk,  cluster_rows=TRUE, cluster_cols=FALSE, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)

dev.off()

png("non_looping_HIF_heatmap_adjust1.png", width=300, height = 800)

pheatmap(m2, color=hmcols, breaks = bk,  cluster_rows=F, cluster_cols=FALSE, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)


dev.off()




#####################################################################
# try other colors hmcols<- colorRampPalette(c("white","blue","blue4"))(100)

png("HIF_heatmap.Raster.png", width =300, height = 800)

pheatmap(m1, color=hmcols, breaks = bk,  cluster_rows=TRUE, cluster_cols=FALSE, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)

heatmap.2(m1, col=hmcols, breaks = bk, Rowv= TRUE , Colv=FALSE, dendrogram="none", useRaster = TRUE, symkey=FALSE, symm=F, symbreaks=T, scale="none", trace="none", labRow=NA, labCol=NA)
# it gave me mysterious error:
# lazy-load database 'P' is corrupt
# I then tested my code in HPC center, it worked fine, seems to be my R setting has
# some problem. Anyway, I finally made it through...
# I restarted the emacs and it worked fine with heatmap.2, my R session went stale.


# do not show the row and column labels 
# trace argument should be put to "none", otherwise the trace is cyan and it will "eat" the heatmap
# I asked in Biostar http://www.biostars.org/p/79444/#79457

dev.off()

# other color schems using library("ColorBrewer")
# col=brewer.pal(9,"Reds")
# display.brewer.all()
########################################################################
#note from Seqanswer
#No bother at all, sorry I didn't get back to this earlier in the day. The "lazy-load database 'P' is corrupt" sounds like a symptom 
#of memory limits, or session corruption, or both. Occasionally I'll have an R session go stale -- either the tempdir() cannot be found 
#or the X-windows lost its authentication. In either case the most time-effective fix is to save the R session (and the history), close
#and re-open R. So did these errors all come from one R session, or are they reproducible each time you open a new R session? I'd check
#that you're indeed running 64-bit R on whatever platform. See if it works fine with only half the rows of data.

#Now for my heatmap power tip of the day, if you will: use the "useRaster=TRUE" parameter in your heatmap.2() call. Excellent extension
#by R developers since 2.13. But for some reason the R developers explicitly turn it off for interactive session windows, so you'll only
#see it in an exported file. (Unless you have a custom image() function which doesn't disable it, I did this.) It also makes the exported
#file hugely smaller, especially for PDFs.

#What it does is darn-near essential for nextgen coverage heatmaps -- it actually properly resamples the image as it down-sizes the image
#during export. Without useRaster=TRUE, image() creates a zillion tiny rectangles to represent the heatmap, all pieced together right next
#to each other. When the display is fewer pixels/points high than the number of rows of data, it discretizes the data -- that is, it uses
#integer values for the rectangles. In many cases, especially onscreen, many rectangles fully overlap others, randomly obscuring the real
#patterns, and often blunting your otherwise cool-looking signal.

#Best way to test is export to PDF with useRaster=FALSE, then do it again with useRaster=TRUE. For me, night and day.

########################################################################

#note from Seqanswer
#No bother at all, sorry I didn't get back to this earlier in the day. The "lazy-load database 'P' is corrupt" sounds like a symptom 
#of memory limits, or session corruption, or both. Occasionally I'll have an R session go stale -- either the tempdir() cannot be found 
#or the X-windows lost its authentication. In either case the most time-effective fix is to save the R session (and the history), close
#and re-open R. So did these errors all come from one R session, or are they reproducible each time you open a new R session? I'd check
#that you're indeed running 64-bit R on whatever platform. See if it works fine with only half the rows of data.

#Now for my heatmap power tip of the day, if you will: use the "useRaster=TRUE" parameter in your heatmap.2() call. Excellent extension
#by R developers since 2.13. But for some reason the R developers explicitly turn it off for interactive session windows, so you'll only
#see it in an exported file. (Unless you have a custom image() function which doesn't disable it, I did this.) It also makes the exported
#file hugely smaller, especially for PDFs.

#What it does is darn-near essential for nextgen coverage heatmaps -- it actually properly resamples the image as it down-sizes the image
#during export. Without useRaster=TRUE, image() creates a zillion tiny rectangles to represent the heatmap, all pieced together right next
#to each other. When the display is fewer pixels/points high than the number of rows of data, it discretizes the data -- that is, it uses
#integer values for the rectangles. In many cases, especially onscreen, many rectangles fully overlap others, randomly obscuring the real
#patterns, and often blunting your otherwise cool-looking signal.

#Best way to test is export to PDF with useRaster=FALSE, then do it again with useRaster=TRUE. For me, night and day.

#######################################################################
# K-means clustering.  the hierachial  clustering did not give me
# satisfiying pattern, I mean a good looking heatmap. below are the way
# to generate a heatmap based on k-means clustering with the same data
# single case
<<<<<<< HEAD
# if I specify the K=2, the data are clustered into to groups, but it ramdomly
# assign one group to 1, the other group to 2, so when use the km$cluster to 
# order the sequence of the matrix, group 1 sometimes show up in the upper part
# of the matrix, sometimes show up in the lower part of the matrix. So does the 
# heatmap. To solve this problem, use the set.seed() funciton. ? set.seed()

set.seed(123)

km<- kmeans(m2,2)   # determin how many cluster you want, I specify 2 here

m.kmeans<- cbind(m2, km$cluster)   # combine the cluster with the matrix


km<- kmeans(m3,2)   # determin how many cluster you want, I specify 2 here

m.kmeans<- cbind(m3, km$cluster)   # combine the cluster with the matrix


dim(m.kmeans)
# [1] 903  602
# the last column is 602
o<- order(m.kmeans[,602]) # order the last column

m.kmeans<- m.kmeans[o,]   # order the matrix according to the order of the last column

png( "Jund_promoter_HRE.png" , width=300, height =800)

pheatmap( m.kmeans[,1:601], cluster_rows = F, cluster_cols = F, col= hmcols, breaks = bk, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)

dev.off()

heatmap.2(m1.kmeans, col=hmcols, breaks = bk, Rowv= FALSE , Colv=FALSE, dendrogram="none", useRaster = TRUE, symkey=FALSE, symm=F, symbreaks=T, scale="none", trace="none", labRow=NA, labCol=NA)

 
################################################################
# order just by the coverage of each probe (each row)
m.row.sum<- cbind(m1, rowSums(m1))
o1<- rev(order(m.row.sum[,602]))

m.row.sum<- m.row.sum[o1,]

bk = unique(c(seq(-0.1,3, length=100),seq(3,10.35,length=100)))

hmcols<- colorRampPalette(c("white","red"))(length(bk)-1)

png("HIF_promoter_HRE.png", width=300, height =800)
pheatmap( m.row.sum[,1:601], cluster_rows = F, cluster_cols = F, col= hmcols, breaks = bk, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)
dev.off()

##################################################################
#################################################################
#create a list to hold the three matrices 
#each element of the list is a list containing name and the matrix data. 
mylist = list(m1=list(name='distal_looping_HRE',data=m1),m2=list(name='distal_non_looping_HRE',data=m2),m3=list(name='promoter_HRE',data=m3))


myfunc<- function(x) {
  m.row.sum<- cbind(x$data, rowSums(x$data))
  o1<- rev(order(m.row.sum[,602]))
  # x$data will be your matrix data
  # x$name will be the name of that matrix
  m.row.sum<- m.row.sum[o1,]
  
  bk = unique(c(seq(-0.1,3, length=100),seq(3,10.35,length=100)))
  
  hmcols<- colorRampPalette(c("white","red"))(length(bk)-1)
  pic.name = paste(x$name,'.png',sep="")
  png(pic.name, width=300, height =800)
  pheatmap( m.row.sum[,1:601], cluster_rows = F, cluster_cols = F, col= hmcols, breaks = bk, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)
  dev.off()
}

# use lapply to loop over list and put it through the myfunc.
lapply(mylist,myfunc)
=======

############################################
# a loop to automate the process
l<- list(a=m1,b=m2,c=m3)

for (name in names(l)) {
  km<- kmeans(l$name,2)   # determin how many cluster you want, I specify 2 here
  
  m.kmeans<- cbind(l$name, km$cluster)   # combine the cluster with the matrix
  
  dim(m.kmeans)
  # [1] 903  602
  # the last column is 602
  o<- order(m.kmeans[,602]) # order the last column
  
  m.kmeans<- m.kmeans[o,]   # order the matrix according to the order of the last column
  
  pic.name <- paste(l$name, "heatmap.png")
  
  png( pic.name , width=300, height =800)
  
  pheatmap( m.kmeans[,1:601], cluster_rows = F, cluster_cols = F, col= hmcols, breaks = bk, legend=FALSE, show_rownames=FALSE, show_colnames=FALSE)
  
  dev.off()
}


# no need to cluster by pheatmap, so I set cluster_rows and cluster_cols to FALSE

##################################################################
heatmap.2(m1.kmeans, col=hmcols, breaks = bk, Rowv= FALSE , Colv=FALSE, dendrogram="none", useRaster = TRUE, symkey=FALSE, symm=F, symbreaks=T, scale="none", trace="none", labRow=NA, labCol=NA)
